2025-01-25 18:38:58 INFO: PROCESSING AssNat...
2025-01-25 18:38:58 INFO: Reading YAML file...
2025-01-25 18:38:58 INFO: Reset option not selected, skipping...
2025-01-25 18:38:58 INFO: Import option not selected, skipping...
2025-01-25 18:38:58 INFO: Enrichment option not selected, skipping...
2025-01-25 18:38:58 INFO: Querying vowels...
2025-01-25 18:38:58 INFO: Querying the corpus for all vowels (no formants)...
2025-01-25 18:38:59 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:00 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:00 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:00 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:00 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:00 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:01 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:01 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:01 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:01 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:02 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:02 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:02 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:02 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:02 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:03 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:03 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:03 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:04 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:04 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:04 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:04 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:04 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:05 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:05 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:05 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:05 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:06 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:06 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:06 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:07 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:07 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:07 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:07 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:08 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:08 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:08 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:08 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:08 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:09 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:09 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:09 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:10 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:10 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:11 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:11 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:11 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:11 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:12 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:12 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:12 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:13 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:13 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:13 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:13 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:13 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:14 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:15 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:15 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:15 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:16 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:16 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:16 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:17 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:17 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:17 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:17 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:17 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:18 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:18 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:18 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:19 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:19 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:19 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:19 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:20 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:20 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:20 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:20 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:21 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:21 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:22 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:22 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:23 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:23 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:23 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:23 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:24 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:24 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:24 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:25 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:25 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:25 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:26 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:28 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:28 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:28 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:29 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:29 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:29 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:29 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:29 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:30 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:30 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:30 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:30 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:30 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:30 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:31 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:31 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:31 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:31 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:32 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:32 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:32 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:32 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:32 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:33 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:33 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:33 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:33 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:33 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:34 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:34 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:34 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:35 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:35 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:35 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:36 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:36 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:36 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:36 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:37 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:37 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:37 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:37 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:38 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:38 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:38 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:38 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:39 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:39 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:40 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:40 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:41 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:41 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:41 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:41 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:41 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:42 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:42 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:42 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:42 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:43 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:43 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:43 INFO: Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Statement.CartesianProduct} {category: PERFORMANCE} {title: This query builds a cartesian product between disconnected patterns.} {description: If a part of a query contains multiple disconnected patterns, this will build a cartesian product between all those parts. This may produce a large amount of data and slow down query processing. While occasionally intended, it may often be possible to reformulate the query that avoids the use of this cross product, perhaps by adding a relationship between the different parts or by using OPTIONAL MATCH (identifiers are: (node_phone_syllable, node_phone_syllable_word, type_node_phone_syllable_word))} {position: line: 1, column: 1, offset: 0} for query: 'MATCH (node_phone)-[:spoken_in]->(node_Discourse:Discourse:AssNat),\n(node_phone_syllable)-[:contained_by]->(node_phone_syllable_word:word:speech:AssNat)-[:is_a]->(type_node_phone_syllable_word:word_type:AssNat),\n(node_phone)-[:spoken_by]->(node_Speaker:Speaker:AssNat),\n(node_phone:phone:speech:AssNat)-[:is_a]->(type_node_phone:phone_type:AssNat),\n(node_phone)-[:contained_by]->(node_phone_syllable:syllable:speech:AssNat)-[:is_a]->(type_node_phone_syllable:syllable_type:AssNat)\n    WHERE type_node_phone:vowel\nAND node_Speaker.name = $`node_Speaker_name`\n    OPTIONAL MATCH (node_phone)<-[:precedes]-(node_prev_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_prev_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_phone)-[:precedes]->(node_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_1_phone:phone_type:AssNat)\nOPTIONAL MATCH (node_foll_1_phone)-[:precedes]->(node_foll_2_foll_1_phone:phone:speech:AssNat)-[:is_a]->(type_node_foll_2_foll_1_phone:phone_type:AssNat)\n\n    WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone\nOPTIONAL MATCH (type_node_phone_in_node_phone_syllable_word:phone_type)<-[:is_a]-(node_phone_in_node_phone_syllable_word:phone:AssNat)-[:contained_by*2]->(node_phone_syllable_word)\n        \n        WITH type_node_phone, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_prev_1_phone, type_node_foll_1_phone, node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_phone) as node_phone_labels, node_foll_1_phone, node_phone_in_node_phone_syllable_word, type_node_phone_in_node_phone_syllable_word\n        \n        ORDER BY node_phone_in_node_phone_syllable_word.begin\n        WITH type_node_foll_1_phone, type_node_phone, node_phone_syllable, labels(node_foll_2_foll_1_phone) as node_foll_2_foll_1_phone_labels, node_phone, node_Discourse, type_node_phone_syllable, node_Speaker, type_node_phone_syllable_word, labels(node_foll_1_phone) as node_foll_1_phone_labels, labels(node_prev_1_phone) as node_prev_1_phone_labels, labels(node_phone_syllable_word) as node_phone_syllable_word_labels, labels(node_phone) as node_phone_labels, node_phone_syllable_word, type_node_foll_2_foll_1_phone, node_foll_2_foll_1_phone, labels(node_phone_syllable) as node_phone_syllable_labels, type_node_prev_1_phone, node_foll_1_phone, node_prev_1_phone, collect(node_phone_in_node_phone_syllable_word) as node_phone_in_node_phone_syllable_word, collect(type_node_phone_in_node_phone_syllable_word) as type_node_phone_in_node_phone_syllable_word\n    RETURN node_Discourse.name AS discourse, node_Speaker.name AS speaker, node_phone.label AS phone, node_phone.end - node_phone.begin AS phone_duration, node_phone.begin AS phone_begin, node_phone.end AS phone_end, reduce(count = 1, n in [x in node_phone_in_node_phone_syllable_word where x.begin < node_phone.begin | x] | count + 1) AS phone_position, node_prev_1_phone.label AS previous_phone, node_foll_1_phone.label AS following_phone, node_foll_2_foll_1_phone.label AS following_following_phone, node_phone_syllable.label AS syllable, node_phone_syllable.begin AS syllable_begin, node_phone_syllable.end AS syllable_end, node_phone_syllable_word.label AS word, type_node_phone_syllable_word.transcription AS transcription, node_phone_syllable_word.begin AS word_begin, node_phone_syllable_word.end AS word_end'
2025-01-25 18:39:43 INFO: COMPLETED PROCESSING FOR CORPUS AssNat.
